#include <iostream>  //input/output stream. (cout,cin이 여기 들어있음)
#include <vector>    //고무줄 배열 std::vector를 쓰기 위한 장치
#include <algorithm> //정렬(sort),이진탐색(binary_search)같은 함수들 들어있음

using namespace std; // c++에선 함수 이름이 겹칠까봐 소속(namespace)를 만드는데 c++ 표준 라이브러리들은 다 std(standard)라는 소속 가짐. 이걸 쓰면 앞으로 std 안붙여도 std 소속인줄 알게됨

int main()
{

    // 코테 볼 때 메인 함수 시작하자마자 무조건 박아넣기
    ios::sync_with_stdio(0); // 원래 c++(cin/cout)은 c(scanf/printf)랑 입출력 순서를 맞추기 위해 동기화(sync)되어 있음. 이 연결을 끊어서 c++만의 독립적 버퍼를 쓰게함. 속도 빨라짐. 단, 이거 쓰면 printf와 cout 섞어쓰면 안됨
    cin.tie(0);              // 원래 입력 받기 전에 혹시 화면에 출력할거 있으면 다 비워(flush)라는 규칙이 있는데, 이걸 끊어서(untie) 입력과 출력 따로 놀게함(코테 채점 프로그램은 사람이 아니니까 데이터 10만개를 0.1초만에 쏟아붓는데, 각 데이터를 입력받기 전 매번 버퍼에 있던거 방출 시도하면 시간 오래걸림->대부분 코테 답변에는 출력 기다리는 안내문구가 없어서 걍 뻘짓)

    int N;
    cin >> N; // 데이터가 키보드(입력 스트립)에서 나와서 변수 N 쪽으로 꽂힌다
              // 서식 지정자 없음. c++은 변수 타입보고 알아서 정수 형태로 입력을 받음
              // 주소연산자(&) 없음. cin은 레퍼런스 기능을 써서 그냥 변수 이름만 주면 알아서 값을 채워줌

    vector<int> v; // int형 데이터를 담을 수 있는 가변 배열 v를 만들어라. 처음에는 크기 0인 빈 껍데기

    int temp;
    for (int i = 0; i < N; i++)
    {
        cin >> temp;
        v.push_back(temp); // 벡터의 맨 뒤에 값을 밀어넣음. 공간이 부족하면 c++이 알아서 메모리를 더 큰 곳으로 이사(realloc)시키고 값을 넣음
    }

    sort(v.begin(), v.end()); // sort(시작점,끝점):범위를 주면 그 안을 오름차순(작은->큰)으로 정렬
                              // v.begin():벡터의 맨 앞(0번 인덱스)를 가리키는 반복자(포인터 비슷한 것, 맨 앞을 가리키는 주소)
                              // v.end():벡터의 맨 마지막 데이터의 다음 칸을 가리킴(끝을 표시하는 깃발 역할,맨 뒤 다음 칸을 가리키는 주소)

    cout << v.front() << " " << v.back(); // 데이터가 변수에서 나와서 화면(출력 스트림,cout) 쪽으로 날아감
                                          // 정렬했으니 맨 앞에는 최솟값(v.front():맨 앖의 '값') 맨 뒤에는 최댓값(v.back():맨 뒤의 '값'). ""는 숫자 사이에 공백 한 칸
                                          //<<를 계속 이어서 쓸 수 있음(값 쏘고 공백 쏘고 값 쏘고), 따로 쓸 수 있음(세줄 됨)

    return 0;
}
